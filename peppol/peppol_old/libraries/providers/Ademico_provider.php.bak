<?php

defined('BASEPATH') or exit('No direct script access allowed');

require_once(__DIR__ . '/Peppol_provider_interface.php');

class Ademico_provider extends Abstract_peppol_provider
{
    private $client_id;
    private $client_secret;
    private $jwt_token;
    private $token_expires_at;
    private $endpoint_url;
    private $token_url;
    private $environment;

    public function __construct()
    {
        $this->CI = &get_instance();
        $this->load_config();
    }

    /**
     * Load provider configuration
     */
    private function load_config()
    {
        $this->client_id = get_option('peppol_ademico_oauth2_client_identifier');
        $this->client_secret = get_option('peppol_ademico_oauth2_client_secret');
        $this->environment = get_option('peppol_environment', 'sandbox');

        // Set OAuth2 URLs based on environment
        $this->endpoint_url = ($this->environment === 'sandbox')
            ? 'https://test-peppol-api.ademico-software.com'
            : 'https://peppol-api.ademico-software.com';
        $this->token_url = ($this->environment === 'sandbox')
            ? 'https://test-peppol-oauth2.ademico-software.com/oauth2/token'
            : 'https://peppol-oauth2.ademico-software.com/oauth2/token';
    }

    /**
     * Get OAuth2 JWT token with caching
     */
    private function get_oauth_token()
    {
        // Check if we have a valid cached token
        if ($this->is_token_valid()) {
            return $this->jwt_token;
        }

        // Try to load token from session cache
        $cached_token = $this->get_cached_token();
        if ($cached_token && $this->is_cached_token_valid($cached_token)) {
            $this->jwt_token = $cached_token['access_token'];
            $this->token_expires_at = $cached_token['expires_at'];
            return $this->jwt_token;
        }

        // Generate new token
        $this->jwt_token = null;
        $this->token_expires_at = null;
        
        return $this->refresh_oauth_token();
    }

    /**
     * Check if current token is valid
     */
    private function is_token_valid()
    {
        return $this->jwt_token && 
               $this->token_expires_at && 
               $this->token_expires_at > time();
    }

    /**
     * Get cached token from session
     */
    private function get_cached_token()
    {
        $cache_key = 'ademico_oauth_token_' . $this->environment . '_' . md5($this->client_id);
        return $this->CI->session->userdata($cache_key);
    }

    /**
     * Check if cached token is valid
     */
    private function is_cached_token_valid($cached_token)
    {
        return isset($cached_token['access_token']) && 
               isset($cached_token['expires_at']) && 
               $cached_token['expires_at'] > time();
    }

    /**
     * Cache token in session
     */
    private function cache_token($access_token, $expires_in)
    {
        $cache_key = 'ademico_oauth_token_' . $this->environment . '_' . md5($this->client_id);
        $expires_at = time() + $expires_in - 60; // Expire 1 minute early for safety
        
        $token_data = [
            'access_token' => $access_token,
            'expires_at' => $expires_at,
            'created_at' => time()
        ];
        
        $this->CI->session->set_userdata($cache_key, $token_data);
        $this->token_expires_at = $expires_at;
    }

    /**
     * Refresh OAuth2 token
     */
    private function refresh_oauth_token()
    {
        // Base64 encode client_id:client_secret for Authorization header
        $credentials = base64_encode($this->client_id . ':' . $this->client_secret);

        $data = [
            'grant_type' => 'client_credentials',
            'scope' => 'peppol/document'
        ];

        $headers = [
            'Authorization: Basic ' . $credentials,
            'Content-Type: application/x-www-form-urlencoded'
        ];

        $response = $this->make_form_request($this->token_url, $data, $headers);

        if (!$response['success']) {
            throw new Exception('OAuth2 authentication failed: ' . $response['message']);
        }

        $token_data = json_decode($response['response'], true);
        if (!isset($token_data['access_token'])) {
            throw new Exception('Invalid OAuth2 response: missing access_token');
        }

        $this->jwt_token = $token_data['access_token'];
        $expires_in = $token_data['expires_in'] ?? 3600; // Default to 1 hour
        
        // Cache the token
        $this->cache_token($this->jwt_token, $expires_in);
        
        return $this->jwt_token;
    }

    /**
     * Get OAuth2 authentication headers
     */
    private function get_auth_headers()
    {
        $jwt_token = $this->get_oauth_token();
        // Note: Ademico API documentation says NOT to use 'Bearer' prefix for JWT
        return ['Authorization: ' . $jwt_token];
    }

    /**
     * Validate OAuth2 configuration
     */
    private function validate_auth_config()
    {
        if (empty($this->client_id) || empty($this->client_secret)) {
            throw new Exception('OAuth2 client ID and client secret are required');
        }
    }

    /**
     * Send document via Ademico PEPPOL API
     */
    public function send_document($ubl_content, $invoice, $client)
    {
        try {
            $this->validate_auth_config();

            // Use correct Ademico API endpoint for invoice submissions
            $endpoint = '/api/peppol/v1/invoices/ubl-submissions';

            $auth_headers = $this->get_auth_headers();

            // Ademico API expects multipart/form-data with UBL XML file
            $response = $this->make_multipart_request($endpoint, $ubl_content, $auth_headers);

            if ($response['success']) {
                $result = $response['data'];
                return [
                    'success' => true,
                    'document_id' => $result['documentId'] ?? null,
                    'transmission_id' => $result['transmissionId'] ?? null,
                    'sbdh_instance_id' => $result['sbdhInstanceIdentifier'] ?? null,
                    'message' => 'Document sent successfully',
                    'response' => $result
                ];
            } else {
                return [
                    'success' => false,
                    'message' => $response['message'] ?? 'Unknown error',
                    'response' => $response
                ];
            }
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => $e->getMessage(),
                'response' => null
            ];
        }
    }

    /**
     * Test connection to Ademico API
     */
    public function test_connection($environment = null)
    {
        try {
            if ($environment) {
                $old_env = $this->environment;
                $this->environment = $environment;
                $this->load_config();
            }

            $this->validate_auth_config();

            $auth_headers = $this->get_auth_headers();
            $headers = array_merge([
                'Accept: application/json'
            ], $auth_headers);

            $response = $this->make_api_request('/api/peppol/v1/tools/connectivity', 'GET', null, $headers);

            if (isset($environment)) {
                $this->environment = $old_env;
                $this->load_config();
            }

            if ($response['success']) {
                return [
                    'success' => true,
                    'message' => 'Connection successful',
                    'response' => $response['data']
                ];
            } else {
                return [
                    'success' => false,
                    'message' => $response['message'] ?? 'Connection failed',
                    'response' => $response
                ];
            }
        } catch (Exception $e) {
            if (isset($environment)) {
                $this->environment = $old_env;
                $this->load_config();
            }

            return [
                'success' => false,
                'message' => $e->getMessage(),
                'response' => null
            ];
        }
    }

    /**
     * Get delivery status of a document using Ademico notifications API
     */
    public function get_delivery_status($transmission_id)
    {
        try {
            $auth_headers = $this->get_auth_headers();
            $headers = array_merge([
                'Accept: application/json'
            ], $auth_headers);

            // Use Ademico's unified notifications API
            $endpoint = '/api/peppol/v1/notifications?transmissionId=' . urlencode($transmission_id);
            $response = $this->make_api_request($endpoint, 'GET', null, $headers);

            if ($response['success']) {
                $notifications = $response['data'];

                if (empty($notifications)) {
                    return [
                        'success' => false,
                        'message' => 'No notifications found for transmission ID',
                        'response' => null
                    ];
                }

                // Get the latest notification
                $latest_notification = $notifications[0];

                // Map Ademico status to internal status
                $internal_status = $this->map_status($latest_notification['documentStatus'] ?? 'unknown');

                return [
                    'success' => true,
                    'status' => $internal_status,
                    'event_type' => $latest_notification['eventType'] ?? null,
                    'notification_date' => $latest_notification['notificationDate'] ?? null,
                    'document_id' => $latest_notification['documentId'] ?? null,
                    'message' => 'Status retrieved successfully',
                    'response' => $latest_notification
                ];
            } else {
                return [
                    'success' => false,
                    'message' => $response['message'] ?? 'Failed to get status',
                    'response' => $response
                ];
            }
        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => $e->getMessage(),
                'response' => null
            ];
        }
    }

    /**
     * Handle webhook from Ademico
     */
    public function handle_webhook()
    {
        try {
            // Get the raw POST data
            $input = file_get_contents('php://input');
            $data = json_decode($input, true);

            if (!$data) {
                throw new Exception('Invalid webhook data');
            }

            // Verify webhook signature if provided
            if (isset($_SERVER['HTTP_X_ADEMICO_SIGNATURE'])) {
                $signature = $_SERVER['HTTP_X_ADEMICO_SIGNATURE'];
                // Use client_secret as webhook signing key for OAuth2
                $expected_signature = hash_hmac('sha256', $input, $this->client_secret);

                if (!hash_equals($signature, $expected_signature)) {
                    throw new Exception('Invalid webhook signature');
                }
            }

            // Process different Ademico webhook events based on specification
            switch ($data['eventType'] ?? '') {
                case 'DOCUMENT_SENT':
                    return $this->process_document_sent($data);
                case 'DOCUMENT_SEND_FAILED':
                    return $this->process_document_send_failed($data);
                case 'MLR_RECEIVED':
                    return $this->process_mlr_received($data);
                case 'INVOICE_RESPONSE_RECEIVED':
                    return $this->process_invoice_response_received($data);
                default:
                    throw new Exception('Unknown webhook event type: ' . ($data['eventType'] ?? 'none'));
            }
        } catch (Exception $e) {
            log_message('error', 'Ademico webhook error: ' . $e->getMessage());
            throw $e;
        }
    }

    /**
     * Process document sent webhook
     */
    private function process_document_sent($data)
    {
        $this->CI->load->model('peppol/peppol_model');

        $transmission_id = $data['transmissionId'] ?? null;
        if ($transmission_id) {
            $peppol_invoice = $this->CI->peppol_model->get_peppol_invoice_by_transmission_id($transmission_id);
            if ($peppol_invoice) {
                $this->CI->peppol_model->update_peppol_invoice_status(
                    $peppol_invoice->id,
                    'sent',
                    [
                        'sent_at' => $data['notificationDate'] ?? date('Y-m-d H:i:s'),
                        'document_status' => $data['documentStatus'] ?? 'SENT'
                    ]
                );
            }
        }

        return null; // No document to process
    }

    /**
     * Process document send failed webhook
     */
    private function process_document_send_failed($data)
    {
        $this->CI->load->model('peppol/peppol_model');

        $transmission_id = $data['transmissionId'] ?? null;
        $error_details = [];

        if (isset($data['details']) && is_array($data['details'])) {
            foreach ($data['details'] as $detail) {
                $error_details[] = $detail['message'] ?? 'Unknown error';
            }
        }

        if ($transmission_id) {
            $peppol_invoice = $this->CI->peppol_model->get_peppol_invoice_by_transmission_id($transmission_id);
            if ($peppol_invoice) {
                $this->CI->peppol_model->update_peppol_invoice_status(
                    $peppol_invoice->id,
                    'failed',
                    [
                        'error_message' => implode('; ', $error_details),
                        'document_status' => $data['documentStatus'] ?? 'SEND_FAILED'
                    ]
                );
            }
        }

        return null; // No document to process
    }

    /**
     * Process MLR (Message Level Response) received webhook
     */
    private function process_mlr_received($data)
    {
        $this->CI->load->model('peppol/peppol_model');

        $transmission_id = $data['transmissionId'] ?? null;
        if ($transmission_id) {
            $peppol_invoice = $this->CI->peppol_model->get_peppol_invoice_by_transmission_id($transmission_id);
            if ($peppol_invoice) {
                // MLR indicates technical acceptance/rejection
                $status = ($data['documentStatus'] === 'ACCEPTED') ? 'delivered' : 'rejected';
                $this->CI->peppol_model->update_peppol_invoice_status(
                    $peppol_invoice->id,
                    $status,
                    [
                        'received_at' => $data['notificationDate'] ?? date('Y-m-d H:i:s'),
                        'document_status' => $data['documentStatus'] ?? 'UNKNOWN'
                    ]
                );
            }
        }

        return null; // No document to process
    }

    /**
     * Process Invoice Response received webhook
     */
    private function process_invoice_response_received($data)
    {
        $this->CI->load->model('peppol/peppol_model');

        $transmission_id = $data['transmissionId'] ?? null;
        if ($transmission_id) {
            $peppol_invoice = $this->CI->peppol_model->get_peppol_invoice_by_transmission_id($transmission_id);
            if ($peppol_invoice) {
                // Invoice Response indicates business acceptance/rejection
                $status = ($data['documentStatus'] === 'ACCEPTED') ? 'acknowledged' : 'rejected';
                $this->CI->peppol_model->update_peppol_invoice_status(
                    $peppol_invoice->id,
                    $status,
                    [
                        'processed_at' => $data['notificationDate'] ?? date('Y-m-d H:i:s'),
                        'document_status' => $data['documentStatus'] ?? 'UNKNOWN'
                    ]
                );
            }
        }

        return null; // No document to process
    }

    /**
     * Make form-encoded HTTP request (for OAuth)
     */
    private function make_form_request($url, $data, $headers = [])
    {
        $ch = curl_init();

        curl_setopt_array($ch, [
            CURLOPT_URL => $url,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_POST => true,
            CURLOPT_POSTFIELDS => http_build_query($data),
            CURLOPT_HTTPHEADER => $headers,
            CURLOPT_TIMEOUT => 30,
            CURLOPT_SSL_VERIFYPEER => true,
            CURLOPT_SSL_VERIFYHOST => 2,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_MAXREDIRS => 3
        ]);

        $response = curl_exec($ch);
        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $curl_error = curl_error($ch);
        curl_close($ch);

        if ($curl_error) {
            return [
                'success' => false,
                'message' => 'cURL error: ' . $curl_error,
                'response' => null
            ];
        }

        if ($http_code >= 200 && $http_code < 300) {
            return [
                'success' => true,
                'response' => $response,
                'http_code' => $http_code
            ];
        } else {
            return [
                'success' => false,
                'message' => 'HTTP error: ' . $http_code,
                'response' => $response,
                'http_code' => $http_code
            ];
        }
    }

    /**
     * Make multipart form request for document submission
     */
    private function make_multipart_request($endpoint, $ubl_content, $auth_headers)
    {
        $url = rtrim($this->endpoint_url, '/') . $endpoint;

        // Create a temporary file for the UBL content
        $temp_file = tempnam(sys_get_temp_dir(), 'peppol_ubl_');
        file_put_contents($temp_file, $ubl_content);

        $ch = curl_init();

        $post_fields = [
            'file' => new CURLFile($temp_file, 'application/xml', 'invoice.xml')
        ];

        $headers = array_merge([
            'Accept: application/json'
        ], $auth_headers);

        curl_setopt_array($ch, [
            CURLOPT_URL => $url,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_POST => true,
            CURLOPT_POSTFIELDS => $post_fields,
            CURLOPT_HTTPHEADER => $headers,
            CURLOPT_TIMEOUT => 30,
            CURLOPT_SSL_VERIFYPEER => true,
            CURLOPT_SSL_VERIFYHOST => 2
        ]);

        $response = curl_exec($ch);
        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $error = curl_error($ch);

        curl_close($ch);

        // Clean up temp file
        unlink($temp_file);

        if ($error) {
            throw new Exception('cURL error: ' . $error);
        }

        $decoded_response = json_decode($response, true);

        return [
            'success' => $http_code >= 200 && $http_code < 300,
            'data' => $decoded_response,
            'message' => $decoded_response['message'] ?? null,
            'http_code' => $http_code,
            'raw_response' => $response
        ];
    }

    /**
     * Download document content from Ademico
     */
    private function download_document($document_id)
    {
        $auth_headers = $this->get_auth_headers();
        $headers = array_merge([
            'Accept: application/xml'
        ], $auth_headers);

        $response = $this->make_api_request('/documents/' . $document_id . '/content', 'GET', null, $headers);

        if ($response['success']) {
            return $response['raw_data']; // Return raw XML content
        } else {
            throw new Exception('Failed to download document content');
        }
    }

    /**
     * Map Ademico status to internal status
     */
    private function map_status($ademico_status)
    {
        $status_map = [
            'QUEUED' => 'pending',
            'SENT' => 'sent',
            'SEND_FAILED' => 'failed',
            'TECHNICAL_ACCEPTANCE' => 'delivered',
            'REJECTED' => 'rejected',
            'ACCEPTED' => 'acknowledged',
            'UNDER_QUERY' => 'pending',
            'FULLY_PAID' => 'processed'
        ];

        return $status_map[$ademico_status] ?? 'unknown';
    }

    /**
     * Make API request to Ademico
     */
    private function make_api_request($endpoint, $method = 'GET', $data = null, $headers = [])
    {
        $url = rtrim($this->endpoint_url, '/') . $endpoint;

        $ch = curl_init();

        curl_setopt_array($ch, [
            CURLOPT_URL => $url,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_TIMEOUT => 30,
            CURLOPT_CUSTOMREQUEST => $method,
            CURLOPT_HTTPHEADER => $headers,
            CURLOPT_SSL_VERIFYPEER => true,
            CURLOPT_SSL_VERIFYHOST => 2
        ]);

        if ($data && in_array($method, ['POST', 'PUT', 'PATCH'])) {
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));
        }

        $response = curl_exec($ch);
        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $error = curl_error($ch);

        curl_close($ch);

        if ($error) {
            throw new Exception('cURL error: ' . $error);
        }

        // For XML content requests, return raw data
        if (strpos(implode(' ', $headers), 'application/xml') !== false) {
            return [
                'success' => $http_code >= 200 && $http_code < 300,
                'raw_data' => $response,
                'http_code' => $http_code
            ];
        }

        $decoded_response = json_decode($response, true);

        return [
            'success' => $http_code >= 200 && $http_code < 300,
            'data' => $decoded_response,
            'message' => $decoded_response['message'] ?? null,
            'http_code' => $http_code,
            'raw_response' => $response
        ];
    }
}